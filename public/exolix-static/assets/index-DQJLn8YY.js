import{a$ as ye,bK as A,b0 as n,bJ as y,b1 as r,b2 as te,ba as c,c4 as W,bm as x,b6 as T,cd as K,bt as oe,ce as se,bn as X,aa as ie,bs as ae,cf as Ae,cg as xe,ch as Te,b8 as B,b9 as $,ci as F,cj as G,ck as D,cl as be,bj as ne,c0 as p,cm as Ee,aU as m,c3 as re,bM as N,bI as S,cn as ve,co as De,b$ as Ne,bT as V,aL as z,bv as ke,cp as Re,cq as Ie,bb as I,bD as P,aN as Pe,aT as J,b4 as Me,cr as Be,bN as $e,bw as Fe,cs as _e,x as ce,ct as Q,cu as Ue,cv as le,cw as We,c2 as Le,cx as Oe,bF as Ge,b3 as Qe,cy as qe,cz as He,cA as Ve}from"./main-CDKDnvW7.js";import{_ as h}from"./App-DCKfOddi.js";import{d as ue,f as w,o as Xe,p as fe,s as Je}from"./exchangeSelectors-C6FOZc8J.js";import{h as M,c as b,e as L,B as Ye,C as O,d as je,w as q,v as pe,E as Ke,D as Z,a as ze,u as Ze,F as v,G as et,H as tt,I as ot}from"./dexTransaction-EqRj2R_J.js";import"./tslib.es6-D9yd9Yl3.js";import"./index-dIKOytT1.js";function Y(e,t){let[a,o="0"]=e.split(".");const i=a.startsWith("-");if(i&&(a=a.slice(1)),o=o.replace(/(0+)$/,""),t===0)Math.round(+`.${o}`)===1&&(a=`${BigInt(a)+1n}`),o="";else if(o.length>t){const[s,l,d]=[o.slice(0,t-1),o.slice(t-1,t),o.slice(t)],u=Math.round(+`${l}.${d}`);u>9?o=`${BigInt(s)+BigInt(1)}0`.padStart(s.length+1,"0"):o=`${s}${u}`,o.length>t&&(o=o.slice(1),a=`${BigInt(a)+1n}`),o=o.slice(0,t)}else o=o.padEnd(t,"0");return BigInt(`${i?"-":""}${a}${o}`)}const at={account:null,balance:{from:null,to:null},chain:{id:A[0].id,code:A[0].code,network:A[0].network}},he=ye({name:"account",initialState:at,reducers:{setAccount:(e,t)=>{e.account=t.payload},setCoinBalance:(e,t)=>{const{selectType:a,coinBalance:o}=t.payload;e.balance[a]=o},setChain:(e,t)=>{e.chain=t.payload}}}),_=he.actions,nt=he.reducer;function*st(e){try{yield n(_.setAccount(e))}catch(t){console.error(t)}}function*ge(e){try{yield n(_.setChain(e)),yield n(y.clearAmountTo()),yield n(y.clearSelectedCoins()),yield n(M.clearCoins()),yield n(M.getCoins()),yield n(y.resetTimer(!0))}catch(t){console.error(t)}}function it(){return oe(e=>Ae(t=>e(t)))}function*rt(){let e=null;try{for(e=yield r(it);e;){const t=yield te(e);yield r(st,t);const a=yield c(b),o=yield c(ue);if(t.chainId&&t.chainId!==a.id){const i=A.find(s=>s.id===t.chainId);i&&(yield r(ge,i))}t.isConnected||o||(yield n(y.setExchangeStep({step:W.STEP_1,source:null})))}}catch(t){console.error(t)}finally{(yield x())&&e&&e.close()}}function*ct(){yield T([_.setAccount,y.setAmount,y.setSelectCoin,y.setExchangeStep],function*(){try{const e=yield c(w),t=yield c(L);if(!t||!t.isConnected||!e.from.coin||!e.to.coin)return;const a=e.from.coin.chain,o=e.to.coin.chain,i=A.find(u=>u.id===Number(a)||u.code.toLowerCase()===a.toLowerCase()),s=A.find(u=>u.id===Number(o)||u.code.toLowerCase()===o.toLowerCase());if(t.chainId!==(i==null?void 0:i.id)||t.chainId!==(s==null?void 0:s.id))return;const l=yield r(se,e.from.coin.symbol,e.from.coin.address),d=yield r(se,e.to.coin.symbol,e.to.coin.address);l&&(yield n(_.setCoinBalance({selectType:X,coinBalance:{decimals:l.decimals,formatted:ie(l.value,l.decimals),symbol:l.symbol}}))),d&&(yield n(_.setCoinBalance({selectType:ae,coinBalance:{decimals:d.decimals,formatted:ie(d.value,d.decimals),symbol:d.symbol}})))}catch(e){console.error(e)}})}function lt(){return oe(e=>{const t=xe(a=>e(a));return()=>{t()}})}function*dt(){let e=null;try{for(e=yield r(lt);e;){const t=yield te(e);t.code===K.ALREADY_PENDING?h("Chain switch is already pending",{duration:6e3,id:"chainSwitchPending"}):(console.error(t),h(t.message,{duration:6e3,id:"chainErr"}))}}catch(t){console.error(t)}finally{(yield x())&&e&&e.close()}}function yt(){return oe(e=>Te(t=>e(t)))}function*ut(){let e=null;try{for(e=yield r(yt);e;){const t=yield te(e);(yield c(b)).id!==t.id&&(yield r(ge,t))}}catch(t){console.error(t)}finally{(yield x())&&e&&e.close()}}const ft=async(e,t)=>{const a=new AbortController,o=B.get(`${t}/tokens`,{params:e,signal:a.signal});return o[$]=()=>a.abort(),(await o).data},pt=35e3;function*ht(){yield T(M.getCoins,gt)}function*gt(){let t=0,a=!0;for(;a;)try{const o=yield c(b),i=yield c(F),s={chainName:o.code};for(;t<3;)try{const l=yield r(ft,s,i);let d=l.filter(u=>u.provider.includes(G.ONE_INCH));d.length===0&&(d=l.filter(u=>u.provider.includes(G.OPEN_OCEAN)),yield n(y.setProviders(`${G.OPEN_OCEAN},${G.ONE_INCH}`))),yield n(M.getCoinsSuccess({coinsResponse:d})),yield r(St,d),yield r(mt);break}catch(l){if(t+=1,t>=3){yield n(M.getCoinsError()),h.error("Failed to request tokens",{duration:6e3}),console.error(l),a=!1;break}else yield D(3e3)}a&&(yield D(pt))}catch(o){console.error(o),a=!1}finally{(yield x())&&(a=!1,yield n(M.cancelGetCoins()))}}function*mt(){try{const e=yield c(Ye),t=yield c(b);if(e.from.initialCoins.length){const a=(s,l)=>{const d=e.from.initialCoins.find(u=>u.symbol.toLowerCase()==s.toLowerCase());return d||e.from.initialCoins[l]};let o=null,i=null;switch(t.code){case"BSC":o=a("BNB",0);break;case"GNOSIS":o=a("XDAI",0);break;case"POLYGON":o=a("MATIC",0);break;case"FANTOM":o=a("FTM",0);break;case"AVALANCHE":o=a("AVAX",0);break;default:o=a("ETH",0)}i||(i=a("USDT",1)),o&&(yield n(y.setSelectCoin({selectType:X,coin:o}))),i&&(yield n(y.setSelectCoin({selectType:ae,coin:i})))}}catch(e){console.error(e)}}function*St(e){try{const t=yield c(w),a=t.from.coin,o=t.to.coin;let i=!1,s=!1;if(a&&o){for(const d of e)if(d.address===a.address&&(i=!0),d.address===o.address&&(s=!0),i&&s)break;const l="isn't available at the moment. Please select another token or come back later.";a.symbol&&!i&&h(`${a.symbol} ${l}`,{duration:9e3}),o.symbol&&!s&&h(`${o.symbol} ${l}`,{duration:9e3}),i&&s?t.coinNotAvailable&&(yield n(y.setCoinNotAvailable(!1))):t.coinNotAvailable||(yield n(y.setCoinNotAvailable(!0)))}}catch(t){console.error(t)}}const wt=async(e,t)=>{const a=new AbortController,o=B.get(`${t}/allowance`,{params:e,signal:a.signal});return o[$]=()=>a.abort(),(await o).data},Ct=async(e,t)=>{const a=new AbortController,o=B.get(`${t}/build-approve-instruction`,{params:e,signal:a.signal});return o[$]=()=>a.abort(),(await o).data},At=async(e,t)=>{const a=new AbortController,o=B.get(`${t}/build-swap-instruction`,{params:e,signal:a.signal});return o[$]=()=>a.abort(),(await o).data},xt=async(e,t)=>{const a=new AbortController,o=B.post(`${t}/send-transaction`,e,{signal:a.signal});return o[$]=()=>a.abort(),(await o).data},Tt=async(e,t)=>{const a=new AbortController,o=B.get(`${t}/get-transaction-status/${e.txHash}`,{params:e.query,signal:a.signal});return o[$]=()=>a.abort(),(await o).data},bt={data:null,fetching:!1,error:!1},me=ye({name:"quotes",initialState:bt,reducers:{getQuotes:{reducer:e=>{e.fetching=!0},prepare:e=>({payload:e})},getQuotesSuccess:(e,t)=>{e.fetching=!1,e.error=!1,e.data=t.payload},getQuotesError:e=>{e.fetching=!1,e.error=!0,e.data=null},getQuotesCancel:e=>{e.fetching=!1}}}),Et=be("quotes/providerChanged"),R={...me.actions,providerChanged:Et},vt=me.reducer;function*Dt(){try{yield ne(300,[_.setAccount,y.setSelectCoin,p.successSwap,R.providerChanged],Nt)}catch(e){console.error(e)}}function*Nt(){let t=0;try{const{from:a,to:o}=yield c(w),i=yield c(b),s=yield c(L),l=yield c(F),d=yield c(O);if(!s||!s.isConnected||!s.address||!a.coin||!o.coin||!a.amount||a.amount==="0"||!d)return;const u=a.coin.chain,f=o.coin.chain,E=A.find(C=>C.id===Number(u)||C.code.toLowerCase()===u.toLowerCase()),k=A.find(C=>C.id===Number(f)||C.code.toLowerCase()===f.toLowerCase());if(s.chainId!==(E==null?void 0:E.id)||s.chainId!==(k==null?void 0:k.id))return;const g={chainName:i.code,spenderAddress:s.address,tokenAddress:a.coin.address,provider:d};for(;t<3;)try{yield n(y.getAllowance());const C=yield r(wt,g,l);yield n(y.getAllowanceSuccess(C.allowance.allowance));break}catch(C){if(t+=1,t>=3){yield n(y.getAllowanceError()),h.error("Failed to request token allowance",{duration:6e3}),console.error(C);break}else yield D(3e3)}finally{(yield x())&&(yield n(y.cancelGetAllowance()))}}catch(a){console.error(a)}}function*kt(){try{yield ne(300,[y.setAmount,y.getAllowanceSuccess],Rt)}catch(e){console.error(e)}}function*Rt(){try{const e=yield c(a=>je(a,X)),t=yield c(w);if(e&&t.from.coin&&t.allowance.data){const a=Y(t.from.amount,t.from.coin.decimals),o=Y(t.allowance.data,t.from.coin.decimals),i=Y(e.formatted,e.decimals),s=i>0n,l=o>0n;if(l&&s&&a<=o&&a<=i)yield n(y.setAllowanceType(q.SWAP));else if(l&&s&&a>o&&a<=i){yield n(y.setAllowanceType(q.APPROVE_DIFFERENCE));const d=Ee(a,o,t.from.coin.decimals);h(`Your current allowance is insufficient for the transaction. Please approve an additional ${d} ${t.from.coin.symbol} to proceed with the swap`,{duration:9e3,id:"approveDifference"})}else!l&&s&&a<=i?yield n(y.setAllowanceType(q.APPROVE)):yield n(y.setAllowanceType(q.INSUFFITIENT_BALANCE))}}catch(e){console.error(e)}}function*U(e){try{e?(yield n(y.setWalletBusy(e)),m()&&(yield n(re(e)))):(yield n(y.setWalletBusy(e)),m()&&(yield n(re(e)))),yield n(y.resetTimer(!0))}catch(t){console.error(t)}}function*It(e){try{m()?yield n(N("swap",!0,"confirmSign")):yield n(S.showSwapModal({show:!0,variant:"confirmSign"}));const t=yield r(ve,e.payload);t&&(yield r(De,Ne,t))&&(m()?(yield n(N("agree",!1)),yield n(N("swap",!1,"confirmSign"))):(yield n(S.showSwapModal({show:!1,variant:"confirmSign"})),yield n(S.showAgreeModal(!1))),yield n(y.setSignedTerms(!0)),V("local","signedTerms",!0))}catch(t){z(t)&&t.includes("timeout")&&(m()?yield n(N("swap",!0,"timeout")):yield n(S.showSwapModal({show:!0,variant:"timeout"}))),console.error(t)}}function*Pt(){try{const e=yield c(ke);yield r(Re);const t=yield r(Ie);if(t&&!t.isConnected&&(yield n(M.getCoins())),e.step&&e.step===W.STEP_2&&(t&&t.isConnected?yield n(y.setExchangeStep({step:W.STEP_2,source:window.parent})):m()&&(yield n(I.postMessage({data:{event:P,payload:{type:"notFound"}},source:null})))),m()){yield n(I.postMessage({data:{event:P,payload:{type:"activeService",payload:Pe.DEX}},source:null}));const u=yield c(pe);yield n(I.postMessage({data:{event:P,payload:{type:"dex/swapData",payload:u}},source:null}))}const a=yield c(w);a.from.amount||(yield n(y.setAmount({amount:e.amountFrom,selectType:X}))),!a.to.amount&&e.amountTo&&(yield n(y.setAmount({amount:e.amountTo,selectType:ae}))),yield n(p.getTransactionStatus());const o=J("local","signedTerms");yield n(y.setSignedTerms(o||!1));const i=J("local","slippage"),s=i?JSON.parse(i):null;s&&(yield n(y.setSettings({settingsType:"slippage",value:s})));const l=J("local","gasPrice"),d=l?JSON.parse(l):null;d&&(yield n(y.setSettings({settingsType:"gasPrice",value:d})))}catch(e){console.error(e)}}function*Mt(){yield T(y.setExchangeStep,function*(e){const{step:t,source:a}=e.payload;try{yield n(I.postMessage({data:{event:P,payload:{type:"dex/setStep",step:t}},source:a}))}catch(o){console.error(o)}})}function*Bt(){yield Me(S.revertExchange,$t)}function*$t(){var e;try{const t=yield c(w),a=yield c(Xe),o=yield c(fe),i=t[a],s=t[o],l=!s.amount||s.amount==="0"?Be:s.amount;yield n(y.setSelectCoin({selectType:a,coin:s.coin})),yield n(y.setSelectCoin({selectType:o,coin:i.coin}));const d=(e=s.coin)==null?void 0:e.decimals;if(d){const u=$e(d,l);yield n(y.setAmount({selectType:a,amount:u}))}}catch(t){console.error(t)}}function*Ft(){yield T(y.signMessage,It)}const _t=async(e,t)=>{const a=new AbortController,o=B.get(`${t}/quotes`,{params:e,signal:a.signal});return o[$]=()=>a.abort(),(await o).data};function*Ut(){try{yield ne(500,[y.setAmount,y.resetTimer,y.setSelectCoin],Wt)}catch(e){console.error(e)}}function*Wt(){try{const{from:e,to:t,settings:a,providers:o}=yield c(w),i=yield c(b),s=yield c(Je),l=Fe(e.amount);if(!e.coin||!t.coin||s||!l)return;const d=e.coin.chain,u=t.coin.chain,f=A.find(g=>g.id===Number(d)||g.code.toLowerCase()===d.toLowerCase()),E=A.find(g=>g.id===Number(u)||g.code.toLowerCase()===u.toLowerCase());if(i.id!==(f==null?void 0:f.id)||i.id!==(E==null?void 0:E.id))return;const k={chainName:i.code,inTokenAddress:e.coin.address,outTokenAddress:t.coin.address,amount:e.amount,slippage:Number(a.slippage.value),inDecimals:e.coin.decimals,sourceProvider:o,targetProvider:o};yield n(R.getQuotes({params:k}))}catch(e){console.error(e)}}function*Lt(){yield T(R.getQuotes,Ot)}function*Ot(e){let a=0;try{const o=yield c(fe),i=yield c(F),{from:s,to:l,coinNotAvailable:d}=yield c(w),u=yield c(O);for(;a<3;)try{const f=yield r(_t,e.payload.params,i);yield n(R.getQuotesSuccess(f)),yield n(y.updateAmount({selectType:o,amount:f.outAmount})),d&&(yield n(y.setCoinNotAvailable(!1))),f.provider!==u&&(yield n(R.providerChanged())),m()&&(yield n(I.postMessage({data:{event:P,payload:{type:"dex/routes",payload:{gasInUsd:f.estimatedGasInUsd,path:f.path,from:s,to:l}}},source:null})));break}catch(f){if(a+=1,a>=3){yield n(R.getQuotesError()),h.error("Failed to request quotes",{duration:6e3}),console.error(f);break}else yield D(3e3)}finally{(yield x())&&(yield n(R.getQuotesCancel()))}}catch(o){console.error(o)}}function*Se(e){try{const t=yield r(we,e);if((yield c(ue))&&(yield n(y.setExchangeStep({step:W.STEP_2,source:null}))),t.txData.txForSign){yield r(ee,!0),yield r(U,!0);const o=yield r(_e,t.txData.txForSign);if(ce(o))yield r(de,e,o);else if(Q(o)&&o===K.METHOD_NOT_SUPPORTED||z(o)&&o.includes("Cannot convert undefined to a BigInt")){const i=yield r(Ue,t.txData.txForSign);ce(i)?yield r(de,e,i):Q(i)&&i===le.USER_REJECTED_REQUEST?yield r(j):Q(i)&&i===K.ENABLE_ETH_SIGN&&(yield D(1e3),yield r(ee,!1),yield r(U,!1),yield n(S.showEthSignMessage(!0)))}else Q(o)&&o===le.USER_REJECTED_REQUEST&&(yield r(j))}}catch(t){z(t)&&t.includes("timeout")&&(yield r(j,"timeout")),console.error(t)}}function*we(e){var t,a;try{const o=yield c(b),i=yield c(w),{buildApprove:s,buildSwap:l}=yield c(Ke);if(yield r(ee,!1),e===Z.APPROVE&&s.data)return{txData:{...s.data,extraData:{inAmount:i.from.amount,outAmount:i.to.amount,inTokenAddress:(t=i.from.coin)==null?void 0:t.address,outTokenAddress:(a=i.to.coin)==null?void 0:a.address,amountFee:"",feeCollectorAddress:""}},chain:o};if(e===Z.SWAP&&l.data)return{txData:l.data,chain:o}}catch(o){console.error(o)}}function*de(e,t){try{const a=yield c(O),o=yield r(we,e);if(a){const i={chainName:o.chain.code,signedTransactionInHex:t,txType:o.txData.txType,extraData:o.txData.extraData,provider:a};yield n(p.postTransaction({params:i}))}}catch(a){console.error(a)}}function*ee(e){try{m()?yield n(N("swap",e,"confirmSwap")):yield n(S.showSwapModal({show:e,variant:"confirmSwap"}))}catch(t){console.error(t)}}function*j(e){try{const t=e||"error";m()?yield n(N("swap",!0,t)):yield n(S.showSwapModal({show:!0,variant:t})),yield r(U,!1)}catch(t){console.error(t)}}function*Gt(){yield T(p.getBuildApprove,function*(){var a;let t=0;try{const o=yield c(w),i=yield c(b),s=yield c(L),l=yield c(F),d=yield c(O);if(s!=null&&s.isConnected&&((a=o.from.coin)!=null&&a.address)&&d){const u={chainName:i.code,spenderAddress:s.address,tokenAddress:o.from.coin.address,amount:o.from.amount,extraGas:o.settings.gasPrice.value,provider:d};for(;t<3;)try{const f=yield r(Ct,u,l);yield n(p.getBuildApproveSuccess(f)),yield r(Ce,f.txType),yield r(Se,f.txType);break}catch(f){if(t+=1,t>=3){yield n(p.getBuildApproveError()),h("Currently not awailable for approve",{duration:6e3,id:"approveError"}),console.error(f);break}else yield D(3e3)}finally{(yield x())&&(yield n(p.cancelGetBuildApprove()))}}}catch(o){console.error(o)}})}function*Qt(){yield T(p.getBuildSwap,function*(){var a,o,i;let t=0;try{const s=yield c(w),l=yield c(b),d=yield c(L),u=yield c(F),f=yield c(O),E=yield r(We);if(d!=null&&d.isConnected&&((a=s.from.coin)!=null&&a.address)&&((o=s.to.coin)!=null&&o.address)&&f){const k={chainName:l.code,inTokenAddress:s.from.coin.address,inDecimals:s.from.coin.decimals,outTokenAddress:s.to.coin.address,amount:s.from.amount,slippage:s.settings.slippage.value,gasPrice:((i=E.gasPrice)==null?void 0:i.toString())||"1",account:d.address,extraGas:s.settings.gasPrice.value,provider:f};for(;t<3;)try{const g=yield r(At,k,u);yield n(p.getBuildSwapSuccess(g)),yield r(Ce,g.txType),yield r(Se,g.txType);break}catch(g){if(t+=1,t>=3){yield n(p.getBuildSwapError()),h("Currently not awailable for swap",{duration:6e3,id:"swapError"}),console.error(g);break}else yield D(3e3)}finally{(yield x())&&(yield n(p.cancelGetBuildSwap()))}}}catch(s){console.error(s)}})}function*Ce(e){try{yield n(p.setTransactionType(e)),Le()&&(yield n(I.postMessage({data:{event:P,payload:{type:"dex/txType",payload:e}},source:null})))}catch(t){console.error(t)}}function*qt(){yield T(p.postTransaction,function*(e){var t,a;try{const o=yield c(w),i=yield c(ze),s=yield c(Ze),l=yield c(F),d=yield r(xt,e.payload.params,l);yield n(S.setShowTxModalFlag(!0)),V("local","dexShowTxModal",!0);const u={from:{coin:o.from.coin,amount:o.from.amount.slice(0,10),amountInUsd:((t=i.data)==null?void 0:t.inAmountInUsd)||"0"},to:{coin:o.to.coin,amount:o.to.amount.slice(0,10),amountInUsd:((a=i.data)==null?void 0:a.outAmountInUsd)||"0"},txType:s,txHash:d};yield n(p.setTransactionSwapData(u)),V("local","dexSwapData",u),m()&&(yield n(I.postMessage({data:{event:P,payload:{type:"dex/swapData",payload:u}},source:null}))),yield n(p.postTransactionSuccess(d)),yield n(p.getTransactionStatus())}catch(o){yield n(p.postTransactionError()),m()?yield n(N("swap",!1,"confirmSwap")):yield n(S.showSwapModal({show:!1,variant:"confirmSwap"})),yield r(U,!1),h.error("Signature error: Please try signing the transaction again.",{id:"postTxError"}),console.error(o)}finally{(yield x())&&(yield n(p.postTransactionCancel()))}})}function*Ht(){yield T(p.getTransactionStatus,Vt)}function*Vt(){let a=0,o=!1;const i=[v.CREATED,v.PENDING];try{const s=yield c(L),l=yield c(pe),d=yield c(b),u=yield c(F);if(s!=null&&s.isConnected&&(l!=null&&l.txHash))for(;!o;)try{const f=yield r(Tt,{txHash:l.txHash,query:{chainName:d.code}},u);if(f)if(yield n(p.getTransactionStatusSuccess(f)),yield r(Xt,f.status,l),yield r(U,!1),i.includes(f.status))yield D(3e3);else{o=!0;break}}catch(f){if(a+=1,a>=3){yield n(p.getTransactionStatusError()),yield r(U,!1),h.error("Failed to request transaction status.",{duration:6e3}),o=!0,console.error(f);break}else yield D(3e3)}finally{(yield x())&&(yield n(p.getTransactionStatusCancel()))}}catch(s){console.error(s)}}function*Xt(e,t){var a,o;try{const i=yield c(et),{from:s,to:l,txType:d}=t||{},u=[v.CREATED,v.PENDING,v.SUCCESS];switch(i&&u.includes(e)&&(d===Z.SWAP&&(yield n(y.setExchangeStep({step:W.STEP_3,source:null}))),m()?yield n(N("swap",!0,"success")):yield n(S.showSwapModal({show:!0,variant:"success"}))),e){case v.SUCCESS:yield n(p.successSwap()),i||(h.success(`Success swap ${s==null?void 0:s.amount} ${(a=s==null?void 0:s.coin)==null?void 0:a.symbol} to ${l==null?void 0:l.amount} ${(o=l==null?void 0:l.coin)==null?void 0:o.symbol}`,{duration:9e3}),yield r(H));break;case v.FAILED:h.error("Failed to send transaction.",{duration:6e3}),yield r(H);break;case v.UNKNOWN:h.error("Unknown trasaction status.",{duration:6e3}),yield r(H);break}}catch(i){console.error(i)}}function*H(){try{yield n(p.setTransactionSwapData(null)),Oe("local","dexSwapData")}catch(e){console.error(e)}}function*Jt(){yield T(p.clearSwapInfo,function*(){try{const e=yield c(tt);yield n(S.setShowTxModalFlag(!1)),V("local","dexShowTxModal",!1),(e==null?void 0:e.status)===v.SUCCESS&&(yield r(H))}catch(e){console.error(e)}})}const to=Ge({coins:ot,quotes:vt,exchange:qe,account:nt,transaction:He,formUi:Ve});function*oo(){try{yield Qe([r(Pt),r(ct),r(ht),r(Bt),r(kt),r(Mt),r(Ut),r(Dt),r(Gt),r(Qt),r(qt),r(Ft),r(Lt),r(Ht),r(Jt),r(rt),r(ut),r(dt)])}catch(e){console.error(e)}}export{to as dexReducer,oo as dexSaga};
